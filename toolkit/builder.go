// Package toolkit provides a hierarchical tool orchestration framework for AI-powered applications.
// This file contains the builder functions (NewChild, NewParent) that simplify the creation
// of tool components without requiring manual interface implementation.
package toolkit

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
)

// --- Child Builder ---

// internalChild implements the Child interface with generic type support.
// It's created by NewChild and wraps the user-provided handler function to handle
// argument unmarshaling, validation, and interface conformance automatically.
type internalChild[ArgsT any] struct {
	name        string
	description string
	handlerFunc func(ctx context.Context, args ArgsT) (interface{}, error)
	schema      interface{} // Cached schema generated by GenerateSchema
}

// NewChild creates a new Child tool definition using a type-safe builder pattern.
// It handles input schema generation, argument validation, and error mapping automatically,
// significantly simplifying tool creation compared to manual interface implementation.
//
// Parameters:
//   - name: The unique name for this child tool within its parent (must be unique within a parent)
//   - description: A human-readable description of what the tool does (used for documentation)
//   - handlerFunc: The function that implements the tool's core logic
//
// The handlerFunc signature must be func(ctx context.Context, args ArgsT) (interface{}, error),
// where ArgsT is a struct type defining the expected arguments. The schema for ArgsT
// is automatically generated from struct tags and type information.
//
// Example:
//
//	type ReadFileArgs struct {
//	    Path string `json:"path" jsonschema:"required,description=File path to read"`
//	}
//
//	type ReadFileResponse struct {
//	    Content string `json:"content"`
//	    Success bool   `json:"success"`
//	}
//
//	readFileTool := toolkit.NewChild(
//	    "read_file",
//	    "Reads content from a file",
//	    func(ctx context.Context, args ReadFileArgs) (interface{}, error) {
//	        content, err := os.ReadFile(args.Path)
//	        if err != nil {
//	            return ReadFileResponse{Success: false}, err
//	        }
//	        return ReadFileResponse{Content: string(content), Success: true}, nil
//	    },
//	)
//
// Returns:
//   - A fully configured Child instance ready to be added to a Parent
func NewChild[ArgsT any](name, description string, handlerFunc func(ctx context.Context, args ArgsT) (interface{}, error)) Child {
	// Use the centralized GenerateSchema helper from types.go
	schema := GenerateSchema[ArgsT]()

	return &internalChild[ArgsT]{
		name:        name,
		description: description,
		handlerFunc: handlerFunc,
		schema:      schema, // Store the generated schema
	}
}

// GetName implements the Child interface by returning the tool's name.
func (c *internalChild[ArgsT]) GetName() string {
	return c.name
}

// GetDescription implements the Child interface by returning the tool's description.
func (c *internalChild[ArgsT]) GetDescription() string {
	return c.description
}

// GetInputSchema implements the Child interface by returning the cached JSON schema.
func (c *internalChild[ArgsT]) GetInputSchema() interface{} {
	return c.schema // Return the cached schema
}

// Handle implements the Child interface by unmarshaling the args and calling the handler.
// It performs several important functions:
//   - Unmarshal the raw JSON arguments into the strongly-typed ArgsT structure
//   - Handle empty/null argument cases gracefully
//   - Call the user-provided handler function with the typed arguments
//   - Convert native Go errors to structured ToolKitError instances
//   - Propagate context to the handler for cancellation/timeout support
func (c *internalChild[ArgsT]) Handle(ctx context.Context, args json.RawMessage) (interface{}, error) {
	var typedArgs ArgsT

	// Handle cases where ArgsT might be an empty struct (no args expected)
	if string(args) == "{}" || string(args) == "" || string(args) == "null" {
		// If ArgsT is not strictly struct{}, unmarshal might fail depending on type.
		// We attempt unmarshal anyway, assuming default zero values are okay for empty input.
		// If ArgsT MUST NOT be empty, the handler func should validate.
	}

	if err := json.Unmarshal(args, &typedArgs); err != nil {
		return nil, NewError("invalid_arguments", fmt.Sprintf("Error unmarshaling arguments for tool '%s': %v. Input: %s", c.name, err, string(args)))
	}

	// Pass the received context down to the handler
	result, err := c.handlerFunc(ctx, typedArgs)
	if err != nil {
		// Check if the error is already a ToolKitError, otherwise wrap it
		if _, ok := err.(ToolKitError); ok {
			return nil, err
		} else {
			return nil, NewError("handler_execution_error", fmt.Sprintf("Error executing tool '%s': %v", c.name, err))
		}
	}

	return result, nil
}

// --- Parent Builder ---

// internalParent implements the Parent interface with a container-based approach.
// It's created by NewParent and manages a collection of Child tools, handling
// tool lookup, execution orchestration, and response aggregation.
type internalParent struct {
	name        string
	description string
	children    map[string]Child // Map of child tools by name for efficient lookup
}

// NewParent creates a new Parent toolkit definition using a builder pattern.
// It groups related Child tools under a common namespace and handles their
// execution orchestration automatically.
//
// Parameters:
//   - name: The unique name for this parent toolkit (must be unique within a Toolkit)
//   - description: A human-readable description of the category's purpose
//   - children: A variadic list of Child instances to include in this parent
//
// Behavior:
//   - Nil children are skipped with a warning
//   - If duplicate child names are detected, the last one overwrites previous instances
//
// Example:
//
//	// Create child tools first
//	readFileTool := toolkit.NewChild("read_file", "Reads a file", handleReadFile)
//	writeFileTool := toolkit.NewChild("write_file", "Writes a file", handleWriteFile)
//
//	// Group them into a parent category
//	fileOpsParent := toolkit.NewParent(
//	    "file_operations",
//	    "Tools for file system operations",
//	    readFileTool, writeFileTool,
//	)
//
// Returns:
//   - A fully configured Parent instance ready to be added to a Toolkit
func NewParent(name, description string, children ...Child) Parent {
	childMap := make(map[string]Child, len(children))
	for _, child := range children {
		if child == nil {
			log.Printf("Warning: nil child provided to NewParent '%s', skipping.", name)
			continue
		}
		if _, exists := childMap[child.GetName()]; exists {
			log.Printf("Warning: Duplicate child name '%s' detected in parent '%s'. Overwriting.", child.GetName(), name)
		}
		childMap[child.GetName()] = child
	}
	return &internalParent{
		name:        name,
		description: description,
		children:    childMap,
	}
}

// GetName implements the Parent interface by returning the parent's name.
func (p *internalParent) GetName() string {
	return p.name
}

// GetDescription implements the Parent interface by returning the parent's description.
func (p *internalParent) GetDescription() string {
	return p.description
}

// GetChildren implements the Parent interface by returning the map of child tools.
// This map is used for tool discovery and schema generation.
func (p *internalParent) GetChildren() map[string]Child {
	// Note: This returns a direct reference to the internal map.
	// In the current design, this is acceptable as the map is only used for
	// read operations after parent creation.
	return p.children
}

// HandleChildren implements the Parent interface by executing the requested child tools.
// It handles the core orchestration logic:
//   - Looking up each requested child by name
//   - Executing child tools with the provided arguments
//   - Capturing successful results and errors in a consistent response format
//   - Ensuring all requests get a response, even if errors occur
//
// Each child is executed sequentially in the order of the requests, with the
// context passed down to each child's Handle method.
func (p *internalParent) HandleChildren(ctx context.Context, childRequests []ToolKitChild) ParentResponse {
	resp := ParentResponse{
		Name:            p.name,
		ChildsResponses: make([]ChildResponse, 0, len(childRequests)),
	}

	for _, req := range childRequests {
		child, ok := p.children[req.Name]
		if !ok {
			log.Printf("Parent '%s': Child '%s' not found.", p.name, req.Name)
			cr := ChildResponse{
				Name:     req.Name,
				Response: NewError("child_not_found", fmt.Sprintf("Child tool '%s' not found within parent '%s'", req.Name, p.name)),
			}
			resp.AddResponse(cr)
			continue
		}

		// Execute the child's handler, passing the context
		result, err := child.Handle(ctx, req.Args)

		// Create child response based on outcome
		var childResp ChildResponse
		if err != nil {
			log.Printf("Parent '%s', Child '%s': Execution error: %v", p.name, req.Name, err)
			childResp = ChildResponse{
				Name:     req.Name,
				Response: err, // Pass the ToolKitError (or wrapped error) directly
			}
		} else {
			childResp = ChildResponse{
				Name:     req.Name,
				Response: result,
			}
		}
		resp.AddResponse(childResp)
	}

	return resp
}
